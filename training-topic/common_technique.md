List of various techniques commonly used in competitive programming, which span across different problem-solving approaches and methodologies:

### Fundamental Techniques:
1. **Brute Force**
   - Exhaustive Search
   - Generating All Subsets, Permutations, Combinations
2. **Greedy Algorithms**
   - Making Locally Optimal Choices at Each Stage
   - Examples: Dijkstra’s Algorithm, Prim’s Algorithm
3. **Divide and Conquer**
   - Breaking Down a Problem into Smaller Subproblems
   - Examples: Merge Sort, Quick Sort
4. **Dynamic Programming**
   - Storing and Reusing Solutions to Subproblems
   - Examples: Knapsack Problem, Longest Common Subsequence
5. **Backtracking**
   - Systematic Search for Solutions by Exploring All Possibilities
   - Examples: N-Queens Problem, Sudoku Solver

### Advanced Techniques:
6. **Binary Search**
   - Efficient Search Technique on Sorted Data
   - Examples: Finding the First Occurrence, Peak Finding
7. **Two-Pointer Technique**
   - Optimized Technique to Process Data Using Two Pointers
   - Examples: Sliding Window, Two Sum Problem
8. **Bit Manipulation**
   - Manipulating Bits to Solve Problems Efficiently
   - Examples: Finding Subset, XOR Operations
9. **Sweep Line Algorithm**
   - Processing Events in a Sorted Order
   - Examples: Line Segment Intersection, Closest Pair of Points
10. **Prefix Sum Arrays**
    - Efficient Calculation of Subarray Sums
    - Examples: Range Sum Queries, Subarray with Given Sum

### Specialized Techniques:
11. **Meet in the Middle**
    - Dividing Problem into Two Halves and Combining Solutions
    - Examples: Subset Sum Problem, Subset with Given Sum
12. **Segment Trees**
    - Efficient Data Structure for Range Queries and Updates
    - Examples: Range Minimum Query, Counting Inversions
13. **Fenwick Tree (Binary Indexed Tree)**
    - Efficient Data Structure for Prefix Sum Queries
    - Examples: Range Sum Queries, Frequency Counting
14. **Suffix Arrays and Suffix Trees**
    - Data Structures for Efficient String Processing
    - Examples: Longest Common Substring, Pattern Matching
15. **Hashing**
    - Mapping Data to Small Range of Values
    - Examples: Hash Map, Hash Set, String Hashing
16. **Probability and Expected Value**
    - Using Probabilistic Techniques to Solve Problems
    - Examples: Expected Value Problems, Monte Carlo Methods
17. **Heuristics and Approximation Algorithms**
    - Finding Near-Optimal Solutions Quickly
    - Examples: Approximate TSP Solutions, Greedy Coloring
18. **Parallel and Concurrent Algorithms**
    - Techniques for Efficient Parallel Execution
    - Examples: Parallel Sorting, Concurrent Data Structures
19. **Metaheuristic Algorithms**
    - High-Level Strategies for Finding Solutions
    - Examples: Genetic Algorithms, Simulated Annealing
20. **Mathematical Transformations**
    - Converting Problems into Different Domains for Simplicity
    - Examples: Fourier Transform, Laplace Transform

### Problem-Solving Strategies:
21. **Reduction Techniques**
    - Transforming Problem into Another Form for Easier Solution
    - Examples: Transforming Graph Problems, NP-Completeness Reductions
22. **Optimization Techniques**
    - Improving Efficiency and Performance of Algorithms
    - Examples: Algorithmic Complexity Analysis, Space-Time Tradeoffs
23. **Pattern Recognition**
    - Identifying Common Patterns in Problems
    - Examples: Sliding Window, Two Pointers
24. **Debugging and Testing**
    - Ensuring Correctness and Efficiency of Solutions
    - Examples: Test Case Design, Edge Case Testing
25. **Algorithmic Paradigms**
    - Choosing Suitable Approaches Based on Problem Characteristics
    - Examples: Divide and Conquer, Dynamic Programming
